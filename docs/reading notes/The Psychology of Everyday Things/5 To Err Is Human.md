Error分为两种，一种是无意识行为的slips，还有一种是有意识行为的mistakes

任务的结构
-----

从两个维度来看：横向与纵向

### 深度与广度兼具的结构

比如棋类游戏，每一步都有很多可能，而且要走很多步，基本上决策树要画到累死的那种。

对于大多数人来说，这种任务十分艰难（还是交给人工智能好了），至少日常生活中不怎么会用到。

### 浅层结构

一般是指有很多选择，但并不需要做出很多个决策的那种任务。

比如从一堆冰淇淋里面选出自己想要的三个球。

我们只需要在每一个决策中将不同的选项区分开来，大部分人都不会觉得很困难。

### 狭窄结构

正好反过来，有很多个需要做的子任务，但每一个子任务都很简单。

（这不就是二叉树嘛）

比如菜谱，做一道菜有很多个步骤，但每一个步骤都并不是特别复杂（一般来讲）。

（浅层结构和狭窄结构可以互相转换，比如遍历一边浅层结构的所有选项然后选择要还是不要hhh）

一个应用是高速公路上的路标设计，为了让司机不晕头转向，一般相关的信息会一点一点出现在出口之前（比如1km提醒一次，500m再提醒一次），并且不会一下子把所有的出口信息都列在一起。

（虽然现在可能用导航软件的比看路标的人多，但导航软件的语音提示也应该是遵循这种规则吧）

### 日常任务的本质

日常生活中要做的事情一般都是浅层结构或者是狭窄结构，毕竟大家都希望把自己的精力用来做一些非日常的复杂任务上嘛。

有意识与无意识的行为
----------

（这本书成书比较早，现在肯定有许多关于意识的更深层次的研究）

关于无意识：很多都是从过去的经验中得来的，不需要仔细思考就能够做的事情。但坏处是可能会有偏见（因为所有的行为都是基于之前得到的信息或者经验）

相对应的是有意识的行为，特点是又慢又累。不管是比较、类比、解释还是逻辑、数学、决策论，都是用来进行有意识行为的工具。

（感觉之前那本畅销书「思考，快与慢」里面说的系统1系统2就是指的这俩）

当然，这两种行为对人类来说都很重要，并不是无意识行为比有意识的low。在很多情况下，它们是互相促进的。

一般来说，人类需要短期记忆来帮助自己做有意识的行为，但人的短期记忆储存量很小，一般也就是五六样东西吧。但是如果找出它们之间的联系，通过类比、推理等将它们梳理成一个结构，就可以记住了。因此理解和解释可以超越人类的记忆极限，让我们记住海量的内容，所以对我们的各种行为非常重要。

所以我们可以找出mistake的产生原因：错配；将当今发生的情况错误地与过去的连系在一起。

大部分人都是事后诸葛亮：当事故发生+知道结果之后，人们很容易会作出合理的解释；但事故发生+不知道结果时，人们作出的解释虽然自洽但经常是错误的。这也是为什么重大事故发生的时候总是错误连着错误，而操作人员总是意识不到；而事故发生之后，调查人员总会对于错误的显而易见而迷惑。

另外就是，社会压力也会造成一些错误。人们总是会在社会压力之下作出一些无可奈何的决策：比如天气不好的时候，要是取消航班，不仅公司损失钱，乘客也不高兴；要是不取消的话，其实大多数情况下还是不会有什么事的，但一万里面要是出了个万一，那就真的出事了。

关注容错性的设计
--------

再熟练的人也会犯错误。为此，我们要针对可能发生的错误行为作出相应的设计。

有几个观点可以参考：

1.  尽可能将错误行为的损失降到最小
2.  让错误的行为可撤销
3.  让任何错误行为的后果容易发现，从而尽可能地进行补救
4.  转换态度，不是所有的错误行为都是无可救药的，可以将它看作「不够完美的近似性尝试」

另外，有的时候人们犯错误，仅仅是因为产品的设计还不够好，外部信息还不够明确，或者有误导性。

作者提出了一个叫做forcing function的概念，用来减少人们犯错的可能性。

forcing function的运行机理是这样的：在行为的很多步骤中，其中一个步骤的上一步是执行下一步的必要条件，如果人们想要执行错误的操作，那么这个错误的操作就会导致上一步无法执行，因此人们也无法执行下一步的操作。

一个很简单的例子是，人们需要车钥匙来运行汽车发动机的引擎。

然而，虽然一些forcing fuction可以防止错误的发生，但也会给用户带来不便——比如发动机开着的时候如果开车门就会有警报，但要是我只想坐在在车里听歌然后开门吹风，就会被警报声吵得受不了。

我们需要权衡这两者，更何况，**迫使用户做不想做的事情，大多没什么好结果**。理想状态下，forcing fuction肯定会对用户的操作造成影响，但只有一点点。

### Safety Engineering中的容错性设计

（其实不管是app的系统设计还是游戏设计……还是单纯的某些轮子，都是同理的呀）

#### Interlock

和forcing function类似，当用户执行了某种操作之后，就会中断某个进程，两个操作无法同时进行，从而阻断了不正当使用方式。

比如在加热过程中开启微波炉的门，就会自动停止加热。

#### Lockin

指某种一直在运行、无法被干预的进程。

比如云文档中的自动保存功能，不管用户是否想要保存，它都会自动存到云端。

#### Lockout

字面意思，把用户挡在外面，无法接触到这个东西。

作者举的例子我在国内没见过，但的确在美国有看到：在一楼和地下室的楼梯之间总会有一个挡板，你需要把它拨开才能下去，稍微有点麻烦。搞这个东西的原因是火灾的时候，所有人都特别慌张，都光顾着往下跑没心思考虑跑到几楼。如果没有一个提醒的东西在，可能很多人都会一直往下冲最后全被堵在地下室了。