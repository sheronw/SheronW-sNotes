# decimal,binary,hex,Two’s Complement Notation


## 二进制转十进制

很简单，从右往左加，第一位乘以2的零次方，第二位乘以2的一次方，然后以此类推……
10101<sub>10</sub>=1\*2^4+0\*2^3+1\*2^2+0\*2^1+1\*2^0=21
还有一种方法是Horner’s Rule，从左往右算，每次把下一位加在这个结果中作为一个整体。
10101<sub>10</sub>=(((1\*2+0)\*2+1)\*2+0)\*2+1=21



## 十进制转二进制
不断地除以二，直到除不动了为止，每一步得到的余数倒过来就是所求的二进制。
- **10**/2=5 ...0
- 5/2=2 ... 1
- 2/2=1 ... 0
- 1/2=0 ... 1

所以10的二进制为1010
当然，如果不想最后再颠倒一遍的话，可以算的时候从下往上写XD


## 十六进制转二进制
十六进制的每一位都能转换成一个四位的二进制，然后把它们拼起来就好，其实还有一个转换表，但算起来也不麻烦，我觉得不背也行。

## 二进制转十六进制
和上面一个道理，每四位二进制都能转换成一位十六进制，如果最后一组不足四位填上几个零就好。

## 十六进制转十进制
和二进制转十进制一个道理，只不过把2换成16了而已。

## 十进制转十六进制
同上，和二进制一样，只不过不断除以16。

## Two’s Complement
这是一种用二进制表达整数（包括正负）的一种方法。
首先，从最左边的那一位可以看出这个数字的正负——0为正，1为负。
如果是正数的话，和之前讲到的传统二进制表达是相同的。
如果是负数的话，想要知道它的具体值，我们需要将Two’s Complement转换成它的相反数（也就是说这个数字的整数版本）。
转换成相反数的算法如下（同时适用与正数和负数）：
- 将每一位的数字颠倒（颠倒指的是，1换成0，0换成1）
- 在颠倒之后的基础上再+1

比如这里有个我瞎编的32bits的数字：
1010 0100 0100 1111 1010 1100 0101 0000
第一位是1，所以这个数是小于零的
首先我们要把它变成这样的：
0101 1011 1011 0000 0101 0011 1010 1111
然后再+1就变成了这样：
0101 1011 1011 0000 0101 0011 1011 0000
这个数就是最前面瞎编的那个数的相反数

哦对了，因为32bits的二进制写起来太长了，所以经常会用十六进制来表示。
